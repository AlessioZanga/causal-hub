# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import numpy
import numpy.typing
import typing

class CatBN:
    r"""
    A categorical Bayesian network (BN).
    """
    def __new__(cls, graph:DiGraph, cpds:typing.Any) -> CatBN:
        r"""
        Constructs a new Bayesian network.
        
        # Arguments
        
        * `graph` - The underlying graph.
        * `cpds` - The conditional probability distributions.
        
        # Returns
        
        A new Bayesian network instance.
        """
    def labels(self) -> builtins.list[builtins.str]:
        r"""
        Returns the labels of the variables.
        
        # Returns
        
        A reference to the labels.
        """
    def graph(self) -> DiGraph:
        r"""
        Returns the underlying graph.
        
        # Returns
        
        A reference to the graph.
        """
    def cpds(self) -> builtins.dict[builtins.str, CatCPD]:
        r"""
        Returns the a map labels-distributions.
        
        # Returns
        
        A reference to the CPDs.
        """
    def parameters_size(self) -> builtins.int:
        r"""
        Returns the parameters size.
        
        # Returns
        
        The parameters size.
        """
    @classmethod
    def from_json(cls, json:builtins.str) -> CatBN:
        r"""
        Read class from a JSON string.
        """
    def to_json(self) -> builtins.str:
        r"""
        Write class to a JSON string.
        """
    @classmethod
    def read_json(cls, path:builtins.str) -> CatBN:
        r"""
        Read class from a JSON file.
        """
    def write_json(self, path:builtins.str) -> None:
        r"""
        Write class to a JSON file.
        """
    @classmethod
    def read_bif(cls, path:builtins.str) -> CatBN:
        r"""
        Read a BIF file and return a CatBN.
        
        # Arguments
        
        * `path` - The path to the BIF file.
        
        # Returns
        
        A new CatBN instance.
        """

class CatCIM:
    r"""
    A struct representing a categorical conditional intensity matrix (CIM).
    """
    def label(self) -> builtins.str:
        r"""
        Returns the label of the conditioned variable.
        
        # Returns
        
        A reference to the label.
        """
    def states(self) -> builtins.list[builtins.str]:
        r"""
        Returns the states of the conditioned variable.
        
        # Returns
        
        The states of the conditioned variable.
        """
    def cardinality(self) -> builtins.int:
        r"""
        Returns the cardinality of the conditioned variable.
        
        # Returns
        
        The cardinality of the conditioned variable.
        """
    def conditioning_labels(self) -> builtins.list[builtins.str]:
        r"""
        Returns the labels of the conditioned variables.
        
        # Returns
        
        A reference to the conditioning labels.
        """
    def conditioning_states(self) -> builtins.dict[builtins.str, tuple]:
        r"""
        Returns the states of the conditioning variables.
        
        # Returns
        
        The states of the conditioning variables.
        """
    def conditioning_cardinality(self) -> builtins.list[builtins.int]:
        r"""
        Returns the cardinality of the conditioning variables.
        
        # Returns
        
        The cardinality of the conditioning variables.
        """
    def parameters(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        Returns the parameters.
        
        # Returns
        
        A reference to the parameters.
        """
    def parameters_size(self) -> builtins.int:
        r"""
        Returns the parameters size.
        
        # Returns
        
        The parameters size.
        """
    def sample_size(self) -> typing.Optional[builtins.float]:
        r"""
        Returns the sample size of the dataset used to fit the distribution, if any.
        
        # Returns
        
        The sample size of the dataset used to fit the distribution.
        """
    def sample_log_likelihood(self) -> typing.Optional[builtins.float]:
        r"""
        Returns the sample log-likelihood of the dataset given the distribution, if any.
        
        # Returns
        
        The sample log-likelihood of the dataset given the distribution.
        """

class CatCPD:
    r"""
    A struct representing a categorical conditional probability distribution (CPD).
    """
    def __new__(cls, state:tuple, conditioning_states:typing.Any, parameters:numpy.typing.NDArray[numpy.float64]) -> CatCPD:
        r"""
        Constructs a new categorical CPD.
        
        # Arguments
        
        * `state` - A tuple containing the label of the conditioned variable and its states.
        * `conditioning_states` - A list of tuples, each containing a label and its states for the conditioning variables.
        * `parameters` - A 2D array of parameters for the CPD.
        
        # Returns
        
        A new `CatCPD` instance.
        """
    def label(self) -> builtins.str:
        r"""
        Returns the label of the conditioned variable.
        
        # Returns
        
        A reference to the label.
        """
    def states(self) -> builtins.list[builtins.str]:
        r"""
        Returns the states of the conditioned variable.
        
        # Returns
        
        The states of the conditioned variable.
        """
    def cardinality(self) -> builtins.int:
        r"""
        Returns the cardinality of the conditioned variable.
        
        # Returns
        
        The cardinality of the conditioned variable.
        """
    def conditioning_labels(self) -> builtins.list[builtins.str]:
        r"""
        Returns the labels of the conditioned variables.
        
        # Returns
        
        A reference to the conditioning labels.
        """
    def conditioning_states(self) -> builtins.dict[builtins.str, tuple]:
        r"""
        Returns the states of the conditioning variables.
        
        # Returns
        
        The states of the conditioning variables.
        """
    def conditioning_cardinality(self) -> builtins.list[builtins.int]:
        r"""
        Returns the cardinality of the conditioning variables.
        
        # Returns
        
        The cardinality of the conditioning variables.
        """
    def parameters(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        Returns the parameters.
        
        # Returns
        
        A reference to the parameters.
        """
    def parameters_size(self) -> builtins.int:
        r"""
        Returns the parameters size.
        
        # Returns
        
        The parameters size.
        """
    def sample_size(self) -> typing.Optional[builtins.float]:
        r"""
        Returns the sample size of the dataset used to fit the distribution, if any.
        
        # Returns
        
        The sample size of the dataset used to fit the distribution.
        """
    def sample_log_likelihood(self) -> typing.Optional[builtins.float]:
        r"""
        Returns the sample log-likelihood of the dataset given the distribution, if any.
        
        # Returns
        
        The sample log-likelihood of the dataset given the distribution.
        """
    def __repr__(self) -> builtins.str:
        r"""
        Returns the string representation of the CatCPD.
        """

class CatCTBN:
    r"""
    A continuous-time Bayesian network (CTBN).
    """
    def __new__(cls, graph:DiGraph, cims:typing.Any) -> CatCTBN:
        r"""
        Constructs a new continuous-time Bayesian network.
        
        # Arguments
        
        * `graph` - The underlying graph.
        * `cims` - The conditional intensity matrices.
        
        # Returns
        
        A new continuous-time Bayesian network instance.
        """
    def labels(self) -> builtins.list[builtins.str]:
        r"""
        Returns the labels of the variables.
        
        # Returns
        
        A reference to the labels.
        """
    def graph(self) -> DiGraph:
        r"""
        Returns the underlying graph.
        
        # Returns
        
        A reference to the graph.
        """
    def cims(self) -> builtins.dict[builtins.str, CatCIM]:
        r"""
        Returns the a map labels-distributions.
        
        # Returns
        
        A reference to the CIMs.
        """
    def parameters_size(self) -> builtins.int:
        r"""
        Returns the parameters size.
        
        # Returns
        
        The parameters size.
        """
    @classmethod
    def from_json(cls, json:builtins.str) -> CatCTBN:
        r"""
        Read class from a JSON string.
        """
    def to_json(self) -> builtins.str:
        r"""
        Write class to a JSON string.
        """
    @classmethod
    def read_json(cls, path:builtins.str) -> CatCTBN:
        r"""
        Read class from a JSON file.
        """
    def write_json(self, path:builtins.str) -> None:
        r"""
        Write class to a JSON file.
        """

class CatTrj:
    r"""
    A categorical trajectory.
    """
    def __new__(cls, df:typing.Any, with_states:typing.Optional[dict]=None) -> CatTrj:
        r"""
        Constructs a new categorical trajectory from a Pandas DataFrame.
        
        # Arguments
        
        * `df` - A Pandas DataFrame containing the trajectory data.
        * `with_states` - An optional dictionary of states.
        
        # Notes
        
        * The data frame must contain a column named "time" that represents the time of each event.
        * Every other column in the data frame must represent a categorical variable.
        
        # Returns
        
        A new categorical trajectory instance.
        """
    def labels(self) -> builtins.list[builtins.str]:
        r"""
        Returns the labels of the categorical trajectory.
        
        # Returns
        
        A reference to the labels of the categorical trajectory.
        """
    def states(self) -> builtins.dict[builtins.str, tuple]:
        r"""
        Returns the states of the categorical trajectory.
        
        # Returns
        
        A reference to the states of the categorical trajectory.
        """
    def times(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        Returns the times of the trajectory.
        
        # Returns
        
        A reference to the times of the trajectory.
        """

class CatTrjEv:
    r"""
    A categorical trajectory evidence.
    """
    def __new__(cls, df:typing.Any, with_states:typing.Optional[dict]=None) -> CatTrjEv:
        r"""
        Constructs a new categorical trajectory evidence from a Pandas DataFrame.
        
        # Arguments
        
        * `df` - A Pandas DataFrame containing the trajectory evidence data.
        * `with_states` - An optional dictionary of states.
        
        # Notes
        
        * The data frame must contain the following columns:
        - `event`: The event type (string).
        - `state`: The state of the event (string).
        - `start_time`: The start time of the event (float64).
        - `end_time`: The end time of the event (float64).
        
        # Returns
        
        A new categorical trajectory evidence instance.
        """
    def labels(self) -> builtins.list[builtins.str]:
        r"""
        Returns the labels of the categorical trajectory.
        
        # Returns
        
        A reference to the labels of the categorical trajectory.
        """
    def states(self) -> builtins.dict[builtins.str, tuple]:
        r"""
        Returns the states of the categorical trajectory.
        
        # Returns
        
        A reference to the states of the categorical trajectory.
        """

class CatTrjs:
    r"""
    A collection of categorical trajectories.
    """
    def __new__(cls, dfs:typing.Any, with_states:typing.Optional[dict]=None) -> CatTrjs:
        r"""
        Constructs a new categorical trajectories from an iterable of Pandas DataFrames.
        
        # Arguments
        
        * `dfs` - An iterable of Pandas DataFrames containing the trajectory data.
        * `with_states` - An optional dictionary of states.
        
        # Notes
        
        * Each data frame must contain a column named "time" that represents the time of each event.
        * Every other column in the data frame must represent a categorical variable.
        
        # Returns
        
        A new categorical trajectories instance.
        """
    def labels(self) -> builtins.list[builtins.str]:
        r"""
        Returns the labels of the categorical trajectory.
        
        # Returns
        
        A reference to the labels of the categorical trajectory.
        """
    def states(self) -> builtins.dict[builtins.str, tuple]:
        r"""
        Returns the states of the categorical trajectory.
        
        # Returns
        
        A reference to the states of the categorical trajectory.
        """
    def values(self) -> builtins.list[CatTrj]:
        r"""
        Return the trajectories.
        
        # Returns
        
        A vector of categorical trajectories.
        """

class CatTrjsEv:
    r"""
    A collection of categorical trajectory evidences.
    """
    def __new__(cls, dfs:typing.Any, with_states:typing.Optional[dict]=None) -> CatTrjsEv:
        r"""
        Constructs a new categorical trajectory evidence from an iterable of Pandas DataFrames.
        
        # Arguments
        
        * `dfs` - An iterable of Pandas DataFrames containing the trajectory evidence data.
        * `with_states` - An optional dictionary of states.
        
        # Notes
        
        * The data frames must contain the following columns:
        - `event`: The event type (string).
        - `state`: The state of the event (string).
        - `start_time`: The start time of the event (float64).
        - `end_time`: The end time of the event (float64).
        
        # Returns
        
        A new categorical trajectory evidence instance.
        """
    def labels(self) -> builtins.list[builtins.str]:
        r"""
        Returns the labels of the categorical trajectory.
        
        # Returns
        
        A reference to the labels of the categorical trajectory.
        """
    def states(self) -> builtins.dict[builtins.str, tuple]:
        r"""
        Returns the states of the categorical trajectory.
        
        # Returns
        
        A reference to the states of the categorical trajectory.
        """

class CatWtdTrj:
    r"""
    A categorical trajectory with a weight.
    """
    def labels(self) -> builtins.list[builtins.str]:
        r"""
        Returns the labels of the categorical trajectory.
        
        # Returns
        
        A reference to the labels of the categorical trajectory.
        """
    def trajectory(self) -> CatTrj:
        r"""
        Returns the trajectory.
        
        # Returns
        
        A reference to the trajectory.
        """
    def weight(self) -> builtins.float:
        r"""
        Returns the weight of the trajectory.
        
        # Returns
        
        The weight of the trajectory.
        """
    def states(self) -> builtins.dict[builtins.str, tuple]:
        r"""
        Returns the states of the categorical trajectory.
        
        # Returns
        
        A reference to the states of the categorical trajectory.
        """
    def times(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        Returns the times of the trajectory.
        
        # Returns
        
        A reference to the times of the trajectory.
        """

class CatWtdTrjs:
    r"""
    A collection of categorical trajectories with weights.
    """
    def labels(self) -> builtins.list[builtins.str]:
        r"""
        Returns the labels of the categorical trajectory.
        
        # Returns
        
        A reference to the labels of the categorical trajectory.
        """
    def states(self) -> builtins.dict[builtins.str, tuple]:
        r"""
        Returns the states of the categorical trajectory.
        
        # Returns
        
        A reference to the states of the categorical trajectory.
        """
    def values(self) -> builtins.list[CatWtdTrj]:
        r"""
        Return the trajectories.
        
        # Returns
        
        A vector of categorical trajectories.
        """

class DiGraph:
    r"""
    A struct representing a directed graph using an adjacency matrix.
    """
    @classmethod
    def empty(cls, labels:typing.Any) -> DiGraph:
        r"""
        Creates an empty directed graph with the given labels.
        
        # Arguments
        
        * `labels` - The labels of the vertices in the graph.
        
        # Notes
        
        * Labels will be sorted in alphabetical order.
        
        # Returns
        
        A new graph instance.
        """
    @classmethod
    def complete(cls, labels:typing.Any) -> DiGraph:
        r"""
        Creates a complete directed graph with the given labels.
        
        # Arguments
        
        * `labels` - The labels of the vertices in the graph.
        
        # Notes
        
        * Labels will be sorted in alphabetical order.
        * No self-loops are created.
        
        # Returns
        
        A new graph instance.
        """
    def vertices(self) -> builtins.list[builtins.str]:
        r"""
        Returns the vertices of the graph.
        
        # Returns
        
        A list of vertices.
        """
    def has_vertex(self, x:builtins.str) -> builtins.bool:
        r"""
        Checks if a vertex exists in the graph.
        
        # Arguments
        
        * `x` - The vertex.
        
        # Returns
        
        `true` if the vertex exists, `false` otherwise.
        """
    def edges(self) -> builtins.list[tuple[builtins.str, builtins.str]]:
        r"""
        Returns the edges of the graph.
        
        # Returns
        
        A list of edges.
        """
    def has_edge(self, x:builtins.str, y:builtins.str) -> builtins.bool:
        r"""
        Checks if there is an edge between vertices `x` and `y`.
        
        # Arguments
        
        * `x` - The first vertex.
        * `y` - The second vertex.
        
        # Returns
        
        `true` if there is an edge between `x` and `y`, `false` otherwise.
        """
    def add_edge(self, x:builtins.str, y:builtins.str) -> builtins.bool:
        r"""
        Adds an edge between vertices `x` and `y`.
        
        # Arguments
        
        * `x` - The first vertex.
        * `y` - The second vertex.
        
        # Returns
        
        `true` if the edge was added, `false` if it already existed.
        """
    def del_edge(self, x:builtins.str, y:builtins.str) -> builtins.bool:
        r"""
        Deletes the edge between vertices `x` and `y`.
        
        # Arguments
        
        * `x` - The first vertex.
        * `y` - The second vertex.
        
        # Returns
        
        `true` if the edge was deleted, `false` if it did not exist.
        """
    def parents(self, x:builtins.str) -> builtins.list[builtins.str]:
        r"""
        Returns the parents of a vertex `x`.
        
        # Arguments
        
        * `x` - The vertex whose parents are to be returned.
        
        # Returns
        
        A list of parent vertices.
        """
    def ancestors(self, x:builtins.str) -> builtins.list[builtins.str]:
        r"""
        Returns the ancestors of a vertex `x`.
        
        # Arguments
        
        * `x` - The vertex whose ancestors are to be returned.
        
        # Returns
        
        A list of ancestor vertices.
        """
    def children(self, x:builtins.str) -> builtins.list[builtins.str]:
        r"""
        Returns the children of a vertex `x`.
        
        # Arguments
        
        * `x` - The vertex whose children are to be returned.
        
        # Returns
        
        A list of child vertices.
        """
    def descendants(self, x:builtins.str) -> builtins.list[builtins.str]:
        r"""
        Returns the descendants of a vertex `x`.
        
        # Arguments
        
        * `x` - The vertex whose descendants are to be returned.
        
        # Returns
        
        A list of descendant vertices.
        """
    def is_separator_set(self, x:typing.Any, y:typing.Any, z:typing.Any) -> builtins.bool:
        r"""
        Checks if the vertex set `Z` is a separator set for `X` and `Y`.
        
        # Arguments
        
        * `x` - An iterable collection of vertices representing set `X`.
        * `y` - An iterable collection of vertices representing set `Y`.
        * `z` - An iterable collection of vertices representing set `Z`.
        
        # Panics
        
        * If any of the vertex in `X`, `Y`, or `Z` are out of bounds.
        * If `X`, `Y` or `Z` are not disjoint sets.
        * If `X` and `Y` are empty sets.
        
        # Returns
        
        `true` if `X` and `Y` are separated by `Z`, `false` otherwise.
        """
    def is_minimal_separator_set(self, x:typing.Any, y:typing.Any, z:typing.Any, w:typing.Optional[typing.Any]=None, v:typing.Optional[typing.Any]=None) -> builtins.bool:
        r"""
        Checks if the vertex set `Z` is a minimal separator set for `X` and `Y`.
        
        # Arguments
        
        * `x` - An iterable collection of vertices representing set `X`.
        * `y` - An iterable collection of vertices representing set `Y`.
        * `z` - An iterable collection of vertices representing set `Z`.
        * `w` - An optional iterable collection of vertices representing set `W`.
        * `v` - An optional iterable collection of vertices representing set `V`.
        
        # Panics
        
        * If any of the vertex in `X`, `Y`, `Z`, `W` or `V` are out of bounds.
        * If `X`, `Y` or `Z` are not disjoint sets.
        * If `X` and `Y` are empty sets.
        * If not `W` <= `Z` <= `V`.
        
        # Returns
        
        `true` if `Z` is a minimal separator set for `X` and `Y`, `false` otherwise.
        """
    def find_minimal_separator_set(self, x:typing.Any, y:typing.Any, w:typing.Optional[typing.Any]=None, v:typing.Optional[typing.Any]=None) -> typing.Optional[builtins.list[builtins.str]]:
        r"""
        Finds a minimal separator set for the vertex sets `X` and `Y`, if any.
        
        # Arguments
        
        * `x` - An iterable collection of vertices representing set `X`.
        * `y` - An iterable collection of vertices representing set `Y`.
        * `w` - An optional iterable collection of vertices representing set `W`.
        * `v` - An optional iterable collection of vertices representing set `V`.
        
        # Panics
        
        * If any of the vertex in `X`, `Y`, `W` or `V` are out of bounds.
        * If `X` and `Y` are not disjoint sets.
        * If `X` or `Y` are empty sets.
        * If not `W` <= `V`.
        
        # Returns
        
        `Some(Set)` containing the minimal separator set, or `None` if no separator set exists.
        """
    @classmethod
    def from_adjacency_matrix(cls, labels:typing.Any, adjacency_matrix:numpy.typing.NDArray[numpy.int64]) -> DiGraph:
        r"""
        Creates a graph from an adjacency matrix and labels.
        
        # Arguments
        
        * `labels` - An iterator over the labels of the vertices.
        * `adjacency_matrix` - A reference to a 2D array representing the adjacency matrix.
        
        # Returns
        
        A new graph instance.
        """
    def to_adjacency_matrix(self) -> numpy.typing.NDArray[numpy.int64]:
        r"""
        Returns the adjacency matrix of the graph.
        
        # Returns
        
        A 2D array representing the adjacency matrix.
        """
    @classmethod
    def from_networkx(cls, g:typing.Any) -> DiGraph:
        r"""
        Converts from a NetworkX DiGraph.
        """
    def to_networkx(self) -> typing.Any:
        r"""
        Converts to a NetworkX DiGraph.
        """

class PK:
    r"""
    A struct representing prior knowledge.
    """
    def __new__(cls, labels:typing.Any, forbidden:typing.Any, required:typing.Any, temporal_order:typing.Any) -> PK: ...

def em(evidence:CatTrjsEv, graph:DiGraph, max_iter:builtins.int=10, seed:builtins.int=42) -> dict:
    r"""
    A function to perform parameter learning using the Expectation Maximization (EM) algorithm.
    """

def load_alarm() -> CatBN:
    r"""
    Load the `ALARM` BN from the assets.
    """

def load_andes() -> CatBN:
    r"""
    Load the `ANDES` BN from the assets.
    """

def load_asia() -> CatBN:
    r"""
    Load the `ASIA` BN from the assets.
    """

def load_barley() -> CatBN:
    r"""
    Load the `BARLEY` BN from the assets.
    """

def load_cancer() -> CatBN:
    r"""
    Load the `CANCER` BN from the assets.
    """

def load_child() -> CatBN:
    r"""
    Load the `CHILD` BN from the assets.
    """

def load_diabetes() -> CatBN:
    r"""
    Load the `DIABETES` BN from the assets.
    """

def load_earthquake() -> CatBN:
    r"""
    Load the `EARTHQUAKE` BN from the assets.
    """

def load_eating() -> CatCTBN:
    r"""
    Load the "EATING" CTBN from the assets.
    """

def load_hailfinder() -> CatBN:
    r"""
    Load the `HAILFINDER` BN from the assets.
    """

def load_hepar2() -> CatBN:
    r"""
    Load the `HEPAR2` BN from the assets.
    """

def load_insurance() -> CatBN:
    r"""
    Load the `INSURANCE` BN from the assets.
    """

def load_link() -> CatBN:
    r"""
    Load the `LINK` BN from the assets.
    """

def load_mildew() -> CatBN:
    r"""
    Load the `MILDEW` BN from the assets.
    """

def load_munin1() -> CatBN:
    r"""
    Load the `MUNIN1` BN from the assets.
    """

def load_pathfinder() -> CatBN:
    r"""
    Load the `PATHFINDER` BN from the assets.
    """

def load_pigs() -> CatBN:
    r"""
    Load the `PIGS` BN from the assets.
    """

def load_sachs() -> CatBN:
    r"""
    Load the `SACHS` BN from the assets.
    """

def load_survey() -> CatBN:
    r"""
    Load the `SURVEY` BN from the assets.
    """

def load_water() -> CatBN:
    r"""
    Load the `WATER` BN from the assets.
    """

def load_win95pts() -> CatBN:
    r"""
    Load the `WIN95PTS` BN from the assets.
    """

def sem(evidence:CatTrjsEv, prior_knowledge:PK, algorithm:builtins.str, max_iter:builtins.int=10, seed:builtins.int=42, **kwargs) -> dict:
    r"""
    A function to perform structure learning using the Structural Expectation Maximization (SEM) algorithm.
    """

