# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import numpy
import numpy.typing
import typing
from causal_hub.datasets import CatTable, CatTrj, GaussTable

class CatBN:
    r"""
    A categorical Bayesian network (BN).
    """
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __new__(cls, graph:DiGraph, cpds:typing.Any) -> CatBN:
        r"""
        Constructs a new Bayesian network.
        
        # Arguments
        
        * `graph` - The underlying graph.
        * `cpds` - The conditional probability distributions.
        
        # Returns
        
        A new Bayesian network instance.
        """
    def name(self) -> typing.Optional[builtins.str]:
        r"""
        Returns the name of the model, if any.
        
        # Returns
        
        The name of the model, if it exists.
        """
    def description(self) -> typing.Optional[builtins.str]:
        r"""
        Returns the description of the model, if any.
        
        # Returns
        
        The description of the model, if it exists.
        """
    def labels(self) -> builtins.list[builtins.str]:
        r"""
        Returns the labels of the variables.
        
        # Returns
        
        A reference to the labels.
        """
    def graph(self) -> DiGraph:
        r"""
        Returns the underlying graph.
        
        # Returns
        
        A reference to the graph.
        """
    def cpds(self) -> builtins.dict[builtins.str, CatCPD]:
        r"""
        Returns the a map labels-distributions.
        
        # Returns
        
        A reference to the CPDs.
        """
    def parameters_size(self) -> builtins.int:
        r"""
        Returns the parameters size.
        
        # Returns
        
        The parameters size.
        """
    @classmethod
    def fit(cls, dataset:CatTable, graph:DiGraph, method:builtins.str='mle', parallel:builtins.bool=True, **kwargs) -> CatBN:
        r"""
        Fit the model to a dataset and a given graph.
        
        # Arguments
        
        * `dataset` - The dataset to fit the model to.
        * `graph` - The graph to fit the model to.
        * `method` - The method to use for fitting (default is `mle`).
        * `parallel` - The flag to enable parallel fitting (default is `true`).
        * `kwargs` - Optional keyword arguments:
            - `alpha` - The prior of the Bayesian estimator.
        
        # Returns
        
        A new fitted model.
        """
    def sample(self, n:builtins.int, seed:builtins.int=31, parallel:builtins.bool=True) -> CatTable:
        r"""
        Generate samples from the model.
        
        # Arguments
        
        * `n` - The number of samples to generate.
        * `seed` - The seed of the random number generator (default is `31`).
        * `parallel` - The flag to enable parallel sampling (default is `true`).
        
        # Returns
        
        A new dataset containing the samples.
        """
    def estimate(self, x:typing.Any, z:typing.Any, seed:builtins.int=31, parallel:builtins.bool=True) -> CatCPD:
        r"""
        Estimate a conditional probability distribution (CPD).
        
        # Arguments
        
        * `x` - A variable or an iterable of variables.
        * `z` - A conditioning variable or an iterable of conditioning variables.
        * `seed` - The seed of the random number generator (default is `31`).
        * `parallel` - The flag to enable parallel estimation (default is `true`).
        
        # Returns
        
        A new conditional probability distribution.
        """
    def do_estimate(self, x:typing.Any, y:typing.Any, z:typing.Any, seed:builtins.int=31, parallel:builtins.bool=True) -> typing.Optional[CatCPD]:
        r"""
        Estimate a conditional causal effect (CACE).
        
        # Arguments
        
        * `x` - An intervention variable or an iterable of intervention variables.
        * `y` - An outcome variable or an iterable of outcome variables.
        * `z` - A conditioning variable or an iterable of conditioning variables.
        * `seed` - The seed of the random number generator (default is `31`).
        * `parallel` - The flag to enable parallel estimation (default is `true`).
        
        # Returns
        
        A new conditional causal effect (CACE) distribution.
        """
    @classmethod
    def from_bif(cls, bif:builtins.str) -> CatBN:
        r"""
        Read class from a BIF string.
        """
    def to_bif(self) -> builtins.str:
        r"""
        Write class to a BIF string.
        """
    @classmethod
    def read_bif(cls, path:builtins.str) -> CatBN:
        r"""
        Read class from a BIF file.
        """
    def write_bif(self, path:builtins.str) -> None:
        r"""
        Write class to a BIF file.
        """
    @classmethod
    def from_json(cls, json:builtins.str) -> CatBN:
        r"""
        Read class from a JSON string.
        """
    def to_json(self) -> builtins.str:
        r"""
        Write class to a JSON string.
        """
    @classmethod
    def read_json(cls, path:builtins.str) -> CatBN:
        r"""
        Read class from a JSON file.
        """
    def write_json(self, path:builtins.str) -> None:
        r"""
        Write class to a JSON file.
        """

class CatCIM:
    r"""
    A struct representing a categorical conditional intensity matrix (CIM).
    """
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def labels(self) -> builtins.list[builtins.str]:
        r"""
        Returns the label of the conditioned variable.
        
        # Returns
        
        A reference to the label.
        """
    def states(self) -> builtins.dict[builtins.str, tuple]:
        r"""
        Returns the states of the conditioned variable.
        
        # Returns
        
        The states of the conditioned variable.
        """
    def shape(self) -> builtins.list[builtins.int]:
        r"""
        Returns the shape of the conditioned variable.
        
        # Returns
        
        The shape of the conditioned variable.
        """
    def conditioning_labels(self) -> builtins.list[builtins.str]:
        r"""
        Returns the labels of the conditioned variables.
        
        # Returns
        
        A reference to the conditioning labels.
        """
    def conditioning_states(self) -> builtins.dict[builtins.str, tuple]:
        r"""
        Returns the states of the conditioning variables.
        
        # Returns
        
        The states of the conditioning variables.
        """
    def conditioning_shape(self) -> builtins.list[builtins.int]:
        r"""
        Returns the shape of the conditioning variables.
        
        # Returns
        
        The shape of the conditioning variables.
        """
    def parameters(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        Returns the parameters.
        
        # Returns
        
        A reference to the parameters.
        """
    def parameters_size(self) -> builtins.int:
        r"""
        Returns the parameters size.
        
        # Returns
        
        The parameters size.
        """
    def sample_statistics(self) -> typing.Optional[dict]:
        r"""
        Returns the sample statistics used to fit the distribution, if any.
        
        # Returns
        
        A dictionary containing the sample statistics used to fit the distribution, if any.
        """
    def sample_log_likelihood(self) -> typing.Optional[builtins.float]:
        r"""
        Returns the sample log-likelihood given the distribution, if any.
        
        # Returns
        
        The sample log-likelihood given the distribution.
        """
    @classmethod
    def from_json(cls, json:builtins.str) -> CatCIM:
        r"""
        Read class from a JSON string.
        """
    def to_json(self) -> builtins.str:
        r"""
        Write class to a JSON string.
        """
    @classmethod
    def read_json(cls, path:builtins.str) -> CatCIM:
        r"""
        Read class from a JSON file.
        """
    def write_json(self, path:builtins.str) -> None:
        r"""
        Write class to a JSON file.
        """

class CatCPD:
    r"""
    A struct representing a categorical conditional probability distribution.
    """
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def labels(self) -> builtins.list[builtins.str]:
        r"""
        Returns the label of the conditioned variable.
        
        # Returns
        
        A reference to the label.
        """
    def states(self) -> builtins.dict[builtins.str, tuple]:
        r"""
        Returns the states of the conditioned variable.
        
        # Returns
        
        The states of the conditioned variable.
        """
    def shape(self) -> builtins.list[builtins.int]:
        r"""
        Returns the shape of the conditioned variable.
        
        # Returns
        
        The shape of the conditioned variable.
        """
    def conditioning_labels(self) -> builtins.list[builtins.str]:
        r"""
        Returns the labels of the conditioned variables.
        
        # Returns
        
        A reference to the conditioning labels.
        """
    def conditioning_states(self) -> builtins.dict[builtins.str, tuple]:
        r"""
        Returns the states of the conditioning variables.
        
        # Returns
        
        The states of the conditioning variables.
        """
    def conditioning_shape(self) -> builtins.list[builtins.int]:
        r"""
        Returns the shape of the conditioning variables.
        
        # Returns
        
        The shape of the conditioning variables.
        """
    def parameters(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        Returns the parameters.
        
        # Returns
        
        A reference to the parameters.
        """
    def parameters_size(self) -> builtins.int:
        r"""
        Returns the parameters size.
        
        # Returns
        
        The parameters size.
        """
    def sample_statistics(self) -> typing.Optional[dict]:
        r"""
        Returns the sample statistics used to fit the distribution, if any.
        
        # Returns
        
        A dictionary containing the sample statistics used to fit the distribution, if any.
        """
    def sample_log_likelihood(self) -> typing.Optional[builtins.float]:
        r"""
        Returns the sample log-likelihood given the distribution, if any.
        
        # Returns
        
        The sample log-likelihood given the distribution.
        """
    def __repr__(self) -> builtins.str:
        r"""
        Returns the string representation of the CatCPD.
        """
    @classmethod
    def from_json(cls, json:builtins.str) -> CatCPD:
        r"""
        Read class from a JSON string.
        """
    def to_json(self) -> builtins.str:
        r"""
        Write class to a JSON string.
        """
    @classmethod
    def read_json(cls, path:builtins.str) -> CatCPD:
        r"""
        Read class from a JSON file.
        """
    def write_json(self, path:builtins.str) -> None:
        r"""
        Write class to a JSON file.
        """

class CatCTBN:
    r"""
    A continuous-time Bayesian network (CTBN).
    """
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __new__(cls, graph:DiGraph, cims:typing.Any) -> CatCTBN:
        r"""
        Constructs a new continuous-time Bayesian network.
        
        # Arguments
        
        * `graph` - The underlying graph.
        * `cims` - The conditional intensity matrices.
        
        # Returns
        
        A new continuous-time Bayesian network instance.
        """
    def name(self) -> typing.Optional[builtins.str]:
        r"""
        Returns the name of the model, if any.
        
        # Returns
        
        The name of the model, if it exists.
        """
    def description(self) -> typing.Optional[builtins.str]:
        r"""
        Returns the description of the model, if any.
        
        # Returns
        
        The description of the model, if it exists.
        """
    def labels(self) -> builtins.list[builtins.str]:
        r"""
        Returns the labels of the variables.
        
        # Returns
        
        A reference to the labels.
        """
    def initial_distribution(self) -> CatBN:
        r"""
        Returns the initial distribution.
        
        # Returns
        
        A reference to the initial distribution.
        """
    def graph(self) -> DiGraph:
        r"""
        Returns the underlying graph.
        
        # Returns
        
        A reference to the graph.
        """
    def cims(self) -> builtins.dict[builtins.str, CatCIM]:
        r"""
        Returns the a map labels-distributions.
        
        # Returns
        
        A reference to the CIMs.
        """
    def parameters_size(self) -> builtins.int:
        r"""
        Returns the parameters size.
        
        # Returns
        
        The parameters size.
        """
    @classmethod
    def fit(cls, dataset:CatTrj, graph:DiGraph, method:builtins.str='mle', seed:builtins.int=31, parallel:builtins.bool=True) -> CatCTBN:
        r"""
        Fit the model to a dataset and a given graph.
        
        # Arguments
        
        * `dataset` - The dataset to fit the model to.
        * `graph` - The graph to fit the model to.
        * `method` - The method to use for fitting (default is `mle`).
        * `seed` - The seed of the random number generator (default is `31`).
        * `parallel` - The flag to enable parallel fitting (default is `true`).
        
        # Returns
        
        A new fitted model.
        """
    @classmethod
    def from_json(cls, json:builtins.str) -> CatCTBN:
        r"""
        Read class from a JSON string.
        """
    def to_json(self) -> builtins.str:
        r"""
        Write class to a JSON string.
        """
    @classmethod
    def read_json(cls, path:builtins.str) -> CatCTBN:
        r"""
        Read class from a JSON file.
        """
    def write_json(self, path:builtins.str) -> None:
        r"""
        Write class to a JSON file.
        """

class DiGraph:
    r"""
    A struct representing a directed graph using an adjacency matrix.
    """
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    @classmethod
    def empty(cls, labels:typing.Any) -> DiGraph:
        r"""
        Creates an empty directed graph with the given labels.
        
        # Arguments
        
        * `labels` - The labels of the vertices in the graph.
        
        # Notes
        
        * Labels will be sorted in alphabetical order.
        
        # Returns
        
        A new graph instance.
        """
    @classmethod
    def complete(cls, labels:typing.Any) -> DiGraph:
        r"""
        Creates a complete directed graph with the given labels.
        
        # Arguments
        
        * `labels` - The labels of the vertices in the graph.
        
        # Notes
        
        * Labels will be sorted in alphabetical order.
        * No self-loops are created.
        
        # Returns
        
        A new graph instance.
        """
    def vertices(self) -> builtins.list[builtins.str]:
        r"""
        Returns the vertices of the graph.
        
        # Returns
        
        A list of vertices.
        """
    def has_vertex(self, x:builtins.str) -> builtins.bool:
        r"""
        Checks if a vertex exists in the graph.
        
        # Arguments
        
        * `x` - The vertex.
        
        # Returns
        
        `true` if the vertex exists, `false` otherwise.
        """
    def edges(self) -> builtins.list[tuple[builtins.str, builtins.str]]:
        r"""
        Returns the edges of the graph.
        
        # Returns
        
        A list of edges.
        """
    def has_edge(self, x:builtins.str, y:builtins.str) -> builtins.bool:
        r"""
        Checks if there is an edge between vertices `x` and `y`.
        
        # Arguments
        
        * `x` - The first vertex.
        * `y` - The second vertex.
        
        # Returns
        
        `true` if there is an edge between `x` and `y`, `false` otherwise.
        """
    def add_edge(self, x:builtins.str, y:builtins.str) -> builtins.bool:
        r"""
        Adds an edge between vertices `x` and `y`.
        
        # Arguments
        
        * `x` - The first vertex.
        * `y` - The second vertex.
        
        # Returns
        
        `true` if the edge was added, `false` if it already existed.
        """
    def del_edge(self, x:builtins.str, y:builtins.str) -> builtins.bool:
        r"""
        Deletes the edge between vertices `x` and `y`.
        
        # Arguments
        
        * `x` - The first vertex.
        * `y` - The second vertex.
        
        # Returns
        
        `true` if the edge was deleted, `false` if it did not exist.
        """
    def parents(self, x:typing.Any) -> builtins.list[builtins.str]:
        r"""
        Returns the parents of a vertex `x`.
        
        # Arguments
        
        * `x` - A vertex or an iterable of vertices.
        
        # Returns
        
        A list of parent vertices.
        """
    def ancestors(self, x:typing.Any) -> builtins.list[builtins.str]:
        r"""
        Returns the ancestors of a vertex `x`.
        
        # Arguments
        
        * `x` - A vertex or an iterable of vertices.
        
        # Returns
        
        A list of ancestor vertices.
        """
    def children(self, x:typing.Any) -> builtins.list[builtins.str]:
        r"""
        Returns the children of a vertex `x`.
        
        # Arguments
        
        * `x` - A vertex or an iterable of vertices.
        
        # Returns
        
        A list of child vertices.
        """
    def descendants(self, x:typing.Any) -> builtins.list[builtins.str]:
        r"""
        Returns the descendants of a vertex `x`.
        
        # Arguments
        
        * `x` - A vertex or an iterable of vertices.
        
        # Returns
        
        A list of descendant vertices.
        """
    def is_separator_set(self, x:typing.Any, y:typing.Any, z:typing.Any) -> builtins.bool:
        r"""
        Checks if the vertex set `Z` is a separator set for `X` and `Y`.
        
        # Arguments
        
        * `x` - An iterable of vertices representing set `X`.
        * `y` - An iterable of vertices representing set `Y`.
        * `z` - An iterable of vertices representing set `Z`.
        
        # Panics
        
        * If any of the vertex in `X`, `Y`, or `Z` are out of bounds.
        * If `X`, `Y` or `Z` are not disjoint sets.
        * If `X` and `Y` are empty sets.
        
        # Returns
        
        `true` if `X` and `Y` are separated by `Z`, `false` otherwise.
        """
    def is_minimal_separator_set(self, x:typing.Any, y:typing.Any, z:typing.Any, w:typing.Optional[typing.Any]=None, v:typing.Optional[typing.Any]=None) -> builtins.bool:
        r"""
        Checks if the vertex set `Z` is a minimal separator set for `X` and `Y`.
        
        # Arguments
        
        * `x` - An iterable of vertices representing set `X`.
        * `y` - An iterable of vertices representing set `Y`.
        * `z` - An iterable of vertices representing set `Z`.
        * `w` - An optional iterable of vertices representing set `W`.
        * `v` - An optional iterable of vertices representing set `V`.
        
        # Panics
        
        * If any of the vertex in `X`, `Y`, `Z`, `W` or `V` are out of bounds.
        * If `X`, `Y` or `Z` are not disjoint sets.
        * If `X` and `Y` are empty sets.
        * If not `W` <= `Z` <= `V`.
        
        # Returns
        
        `true` if `Z` is a minimal separator set for `X` and `Y`, `false` otherwise.
        """
    def find_minimal_separator_set(self, x:typing.Any, y:typing.Any, w:typing.Optional[typing.Any]=None, v:typing.Optional[typing.Any]=None) -> typing.Optional[builtins.list[builtins.str]]:
        r"""
        Finds a minimal separator set for the vertex sets `X` and `Y`, if any.
        
        # Arguments
        
        * `x` - An iterable of vertices representing set `X`.
        * `y` - An iterable of vertices representing set `Y`.
        * `w` - An optional iterable of vertices representing set `W`.
        * `v` - An optional iterable of vertices representing set `V`.
        
        # Panics
        
        * If any of the vertex in `X`, `Y`, `W` or `V` are out of bounds.
        * If `X` and `Y` are not disjoint sets.
        * If `X` or `Y` are empty sets.
        * If not `W` <= `V`.
        
        # Returns
        
        `Some(Set)` containing the minimal separator set, or `None` if no separator set exists.
        """
    def is_backdoor_set(self, x:typing.Any, y:typing.Any, z:typing.Any) -> builtins.bool:
        r"""
        Checks if the vertex set `Z` is a backdoor set for `X` and `Y`.
        
        # Arguments
        
        * `x` - An iterable of vertices representing set `X`.
        * `y` - An iterable of vertices representing set `Y`.
        * `z` - An iterable of vertices representing set `Z`.
        
        # Panics
        
        * If any of the vertex in `X`, `Y`, or `Z` are out of bounds.
        * If `X`, `Y` or `Z` are not disjoint sets.
        * If `X` and `Y` are empty sets.
        
        # Returns
        
        `true` if `X` and `Y` are separated by `Z`, `false` otherwise.
        """
    def is_minimal_backdoor_set(self, x:typing.Any, y:typing.Any, z:typing.Any, w:typing.Optional[typing.Any]=None, v:typing.Optional[typing.Any]=None) -> builtins.bool:
        r"""
        Checks if the vertex set `Z` is a minimal backdoor set for `X` and `Y`.
        
        # Arguments
        
        * `x` - An iterable of vertices representing set `X`.
        * `y` - An iterable of vertices representing set `Y`.
        * `z` - An iterable of vertices representing set `Z`.
        * `w` - An optional iterable of vertices representing set `W`.
        * `v` - An optional iterable of vertices representing set `V`.
        
        # Panics
        
        * If any of the vertex in `X`, `Y`, `Z`, `W` or `V` are out of bounds.
        * If `X`, `Y` or `Z` are not disjoint sets.
        * If `X` and `Y` are empty sets.
        * If not `W` <= `Z` <= `V`.
        
        # Returns
        
        `true` if `Z` is a minimal backdoor set for `X` and `Y`, `false` otherwise.
        """
    def find_minimal_backdoor_set(self, x:typing.Any, y:typing.Any, w:typing.Optional[typing.Any]=None, v:typing.Optional[typing.Any]=None) -> typing.Optional[builtins.list[builtins.str]]:
        r"""
        Finds a minimal backdoor set for the vertex sets `X` and `Y`, if any.
        
        # Arguments
        
        * `x` - An iterable of vertices representing set `X`.
        * `y` - An iterable of vertices representing set `Y`.
        * `w` - An optional iterable of vertices representing set `W`.
        * `v` - An optional iterable of vertices representing set `V`.
        
        # Panics
        
        * If any of the vertex in `X`, `Y`, `W` or `V` are out of bounds.
        * If `X` and `Y` are not disjoint sets.
        * If `X` or `Y` are empty sets.
        * If not `W` <= `V`.
        
        # Returns
        
        `Some(Set)` containing the minimal backdoor set, or `None` if no backdoor set exists.
        """
    @classmethod
    def from_adjacency_matrix(cls, labels:typing.Any, adjacency_matrix:numpy.typing.NDArray[numpy.int64]) -> DiGraph:
        r"""
        Creates a graph from an adjacency matrix and labels.
        
        # Arguments
        
        * `labels` - An iterator over the labels of the vertices.
        * `adjacency_matrix` - A reference to a 2D array representing the adjacency matrix.
        
        # Returns
        
        A new graph instance.
        """
    def to_adjacency_matrix(self) -> numpy.typing.NDArray[numpy.int64]:
        r"""
        Returns the adjacency matrix of the graph.
        
        # Returns
        
        A 2D array representing the adjacency matrix.
        """
    @classmethod
    def from_networkx(cls, g:typing.Any) -> DiGraph:
        r"""
        Converts from a NetworkX DiGraph.
        """
    def to_networkx(self) -> typing.Any:
        r"""
        Converts to a NetworkX DiGraph.
        """
    @classmethod
    def from_json(cls, json:builtins.str) -> DiGraph:
        r"""
        Read class from a JSON string.
        """
    def to_json(self) -> builtins.str:
        r"""
        Write class to a JSON string.
        """
    @classmethod
    def read_json(cls, path:builtins.str) -> DiGraph:
        r"""
        Read class from a JSON file.
        """
    def write_json(self, path:builtins.str) -> None:
        r"""
        Write class to a JSON file.
        """

class GaussBN:
    r"""
    A Gaussian Bayesian network.
    """
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def __new__(cls, graph:DiGraph, cpds:typing.Any) -> GaussBN:
        r"""
        Constructs a new Bayesian network.
        
        # Arguments
        
        * `graph` - The underlying graph.
        * `cpds` - The conditional probability distributions.
        
        # Returns
        
        A new Bayesian network instance.
        """
    def name(self) -> typing.Optional[builtins.str]:
        r"""
        Returns the name of the model, if any.
        
        # Returns
        
        The name of the model, if it exists.
        """
    def description(self) -> typing.Optional[builtins.str]:
        r"""
        Returns the description of the model, if any.
        
        # Returns
        
        The description of the model, if it exists.
        """
    def labels(self) -> builtins.list[builtins.str]:
        r"""
        Returns the labels of the variables.
        
        # Returns
        
        A reference to the labels.
        """
    def graph(self) -> DiGraph:
        r"""
        Returns the underlying graph.
        
        # Returns
        
        A reference to the graph.
        """
    def cpds(self) -> builtins.dict[builtins.str, GaussCPD]:
        r"""
        Returns the a map labels-distributions.
        
        # Returns
        
        A reference to the CPDs.
        """
    def parameters_size(self) -> builtins.int:
        r"""
        Returns the parameters size.
        
        # Returns
        
        The parameters size.
        """
    @classmethod
    def fit(cls, dataset:GaussTable, graph:DiGraph, method:builtins.str='mle', seed:builtins.int=31, parallel:builtins.bool=True) -> GaussBN:
        r"""
        Fit the model to a dataset and a given graph.
        
        # Arguments
        
        * `dataset` - The dataset to fit the model to.
        * `graph` - The graph to fit the model to.
        * `method` - The method to use for fitting (default is `mle`).
        * `seed` - The seed of the random number generator (default is `31`).
        * `parallel` - The flag to enable parallel fitting (default is `true`).
        
        # Returns
        
        A new fitted model.
        """
    def sample(self, n:builtins.int, seed:builtins.int=31, parallel:builtins.bool=True) -> GaussTable:
        r"""
        Generate samples from the model.
        
        # Arguments
        
        * `n` - The number of samples to generate.
        * `seed` - The seed of the random number generator (default is `31`).
        * `parallel` - The flag to enable parallel sampling (default is `true`).
        
        # Returns
        
        A new dataset containing the samples.
        """
    def estimate(self, x:typing.Any, z:typing.Any, method:builtins.str='approximate', seed:builtins.int=31, parallel:builtins.bool=True) -> GaussCPD:
        r"""
        Estimate a conditional probability distribution.
        
        # Arguments
        
        * `x` - A variable or an iterable of variables.
        * `z` - A conditioning variable or an iterable of conditioning variables.
        * `method` - The method to use for estimation (default is `approximate`).
        * `seed` - The seed of the random number generator (default is `31`).
        * `parallel` - The flag to enable parallel estimation (default is `true`).
        
        # Returns
        
        A new conditional probability distribution.
        """
    def do_estimate(self, x:typing.Any, y:typing.Any, z:typing.Any, method:builtins.str='approximate', seed:builtins.int=31, parallel:builtins.bool=True) -> GaussCPD:
        r"""
        Estimate a conditional causal effect (CACE).
        
        # Arguments
        
        * `x` - An intervention variable or an iterable of intervention variables.
        * `y` - An outcome variable or an iterable of outcome variables.
        * `z` - A conditioning variable or an iterable of conditioning variables.
        * `method` - The method to use for estimation (default is `approximate`).
        * `seed` - The seed of the random number generator (default is `31`).
        * `parallel` - The flag to enable parallel estimation (default is `true`).
        
        # Returns
        
        A new conditional causal effect (CACE) distribution.
        """
    @classmethod
    def from_json(cls, json:builtins.str) -> GaussBN:
        r"""
        Read class from a JSON string.
        """
    def to_json(self) -> builtins.str:
        r"""
        Write class to a JSON string.
        """
    @classmethod
    def read_json(cls, path:builtins.str) -> GaussBN:
        r"""
        Read class from a JSON file.
        """
    def write_json(self, path:builtins.str) -> None:
        r"""
        Write class to a JSON file.
        """

class GaussCPD:
    r"""
    A struct representing a Gaussian conditional probability distribution.
    """
    def __eq__(self, other:builtins.object) -> builtins.bool: ...
    def labels(self) -> builtins.list[builtins.str]:
        r"""
        Returns the label of the conditioned variable.
        
        # Returns
        
        A reference to the label.
        """
    def conditioning_labels(self) -> builtins.list[builtins.str]:
        r"""
        Returns the labels of the conditioned variables.
        
        # Returns
        
        A reference to the conditioning labels.
        """
    def parameters(self) -> typing.Optional[dict]:
        r"""
        Returns the parameters.
        
        # Returns
        
        A reference to the parameters.
        """
    def parameters_size(self) -> builtins.int:
        r"""
        Returns the parameters size.
        
        # Returns
        
        The parameters size.
        """
    def sample_statistics(self) -> typing.Optional[dict]:
        r"""
        Returns the sample statistics used to fit the distribution, if any.
        
        # Returns
        
        A dictionary containing the sample statistics used to fit the distribution, if any.
        """
    def sample_log_likelihood(self) -> typing.Optional[builtins.float]:
        r"""
        Returns the sample log-likelihood given the distribution, if any.
        
        # Returns
        
        The sample log-likelihood given the distribution.
        """
    @classmethod
    def from_json(cls, json:builtins.str) -> GaussCPD:
        r"""
        Read class from a JSON string.
        """
    def to_json(self) -> builtins.str:
        r"""
        Write class to a JSON string.
        """
    @classmethod
    def read_json(cls, path:builtins.str) -> GaussCPD:
        r"""
        Read class from a JSON file.
        """
    def write_json(self, path:builtins.str) -> None:
        r"""
        Write class to a JSON file.
        """

